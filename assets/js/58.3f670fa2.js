(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{428:function(a,t,s){"use strict";s.r(t);var r=s(46),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"evm-变量存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#evm-变量存储"}},[a._v("#")]),a._v(" EVM 变量存储")]),a._v(" "),s("h5",{attrs:{id:"在以太坊中-有俩种空间可以保存合约的字段变量-一个是内存、另一个是存储-一旦变量保存在存储中就意味这变量的值将永远会记录在区块链状态中-那么一个合约如此多的变量如何让彼此不重叠呢-这要讲到-evm-的卡槽了"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在以太坊中-有俩种空间可以保存合约的字段变量-一个是内存、另一个是存储-一旦变量保存在存储中就意味这变量的值将永远会记录在区块链状态中-那么一个合约如此多的变量如何让彼此不重叠呢-这要讲到-evm-的卡槽了"}},[a._v("#")]),a._v(" "),s("span",{attrs:{id:"gonglian"}},[a._v("  在以太坊中，有俩种空间可以保存合约的字段变量，一个是内存、另一个是存储，一旦变量保存在存储中就意味这变量的值将永远会记录在区块链状态中，那么一个合约如此多的变量如何让彼此不重叠呢？这要讲到 EVM 的卡槽了 ")])]),a._v(" "),s("h4",{attrs:{id:"evm-卡槽"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#evm-卡槽"}},[a._v("#")]),a._v("   EVM 卡槽")]),a._v(" "),s("p",[a._v("    EVM 使用卡槽来保存变量，因为 first 变量声明在 Sample 合约的最前面，所有就分配了第 0 下标的卡槽来记录这\n    个变量的状态。 每一个不同的变量都依次递增得通过其卡槽下标来标识  "),s("span",{attrs:{id:"gonglian"}},[a._v("  (映射和动态大小数组是此规则的例外) ")])]),a._v(" "),s("div",{staticClass:"language-angular2 extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("contract Sample{\n    uint256 first;              // slot 1\n    uint256 second;             // slot 2    \n}\n")])])]),s("h5",{attrs:{id:"在-evm-中-每一个智能合约的存储中具有-2-256-次方个卡槽-在-evm-中-每一个卡槽都可以保存-32-字节大小的数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在-evm-中-每一个智能合约的存储中具有-2-256-次方个卡槽-在-evm-中-每一个卡槽都可以保存-32-字节大小的数据"}},[a._v("#")]),a._v(" 在 EVM 中，每一个智能合约的存储中具有 2 * 256 次方个卡槽 "),s("br"),a._v("在 EVM 中，每一个卡槽都可以保存 32 字节大小的数据")]),a._v(" "),s("h2",{attrs:{id:"delegatecall"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#delegatecall"}},[a._v("#")]),a._v(" Delegatecall")]),a._v(" "),s("h5",{attrs:{id:"但-caller-合约使用委托调用-target-目标合约时-被调用的-target-合约函数的执行逻辑将会在-caller-合约上下文中执行。所有的状态更改逻辑都会反映在-caller-合约得存储卡槽上。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#但-caller-合约使用委托调用-target-目标合约时-被调用的-target-合约函数的执行逻辑将会在-caller-合约上下文中执行。所有的状态更改逻辑都会反映在-caller-合约得存储卡槽上。"}},[a._v("#")]),a._v(" "),s("span",{attrs:{id:"gonglian"}},[a._v("  但 caller 合约使用委托调用 target 目标合约时，被调用的 target 合约函数的执行逻辑将会在 caller 合约上下文中执行。所有的状态更改逻辑都会反映在 caller 合约得存储卡槽上。 ")])]),a._v(" "),s("h4",{attrs:{id:"列如"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#列如"}},[a._v("#")]),a._v("   列如")]),a._v(" "),s("p",[a._v("    当我们有一个代理合约和业务合约，而代理合约存储状态的卡槽位置，而业务合约存放的是该更状态逻辑，当用户调用代\n    理合约时，则代理合约将会委托调用业务合约，并执行函数逻辑，所有状态的更改都反映在代理合约存储中，而不是业务\n    合约")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[a._v("\n                call                                 delegateCall                              \n"),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("EOA")]),a._v(" 用户   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("    "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("CALLER")]),a._v(" Contract   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("    "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("TARGET")]),a._v(" Contract\n                          msg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("sender "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("EOA")]),a._v(" address                  msg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("sender "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("EOA")]),a._v(" address    \n                          msg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("value "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("EOA")]),a._v(" send value                msg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("value "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("EOA")]),a._v(" send value    \n\n")])])]),s("h2",{attrs:{id:"升级合约-标准"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#升级合约-标准"}},[a._v("#")]),a._v(" 升级合约-标准")]),a._v(" "),s("h5",{attrs:{id:"现在的升级合约-目前都是采用-delegatecall-模式来对合约升级-这个模式虽然最为主流-但是区块链的不可改变的特新-也给合约升级带来了各种限制-下面就讲解各种限制以及如何应对这些限制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#现在的升级合约-目前都是采用-delegatecall-模式来对合约升级-这个模式虽然最为主流-但是区块链的不可改变的特新-也给合约升级带来了各种限制-下面就讲解各种限制以及如何应对这些限制"}},[a._v("#")]),a._v(" "),s("span",{attrs:{id:"gonglian"}},[a._v("  现在的升级合约，目前都是采用 delegatecall 模式来对合约升级，这个模式虽然最为主流，但是区块链的不可改变的特新，也给合约升级带来了各种限制，下面就讲解各种限制以及如何应对这些限制 ")])]),a._v(" "),s("h1",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[a._v("#")])]),a._v(" "),s("h4",{attrs:{id:"代理合约与逻辑合约"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代理合约与逻辑合约"}},[a._v("#")]),a._v("   #代理合约与逻辑合约")]),a._v(" "),s("div",{staticClass:"language-angular2 extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("s\n")])])]),s("h4",{attrs:{id:"管理升级逻辑合约地址函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#管理升级逻辑合约地址函数"}},[a._v("#")]),a._v("   #管理升级逻辑合约地址函数")]),a._v(" "),s("h4",{attrs:{id:"选择器冲突与透明代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#选择器冲突与透明代理"}},[a._v("#")]),a._v("   #选择器冲突与透明代理")]),a._v(" "),s("h4",{attrs:{id:"uups-通用升级代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#uups-通用升级代理"}},[a._v("#")]),a._v("   #UUPS 通用升级代理")]),a._v(" "),s("h4",{attrs:{id:"代理合约的存储冲突与非结构化存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代理合约的存储冲突与非结构化存储"}},[a._v("#")]),a._v("   #代理合约的存储冲突与非结构化存储")]),a._v(" "),s("h4",{attrs:{id:"存储布局与追加存储和永久存储的兼容性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#存储布局与追加存储和永久存储的兼容性"}},[a._v("#")]),a._v("   #存储布局与追加存储和永久存储的兼容性")]),a._v(" "),s("h4",{attrs:{id:"逻辑合约得限制与初始化问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#逻辑合约得限制与初始化问题"}},[a._v("#")]),a._v("   #逻辑合约得限制与初始化问题")]),a._v(" "),s("h2",{attrs:{id:"升级模式-砖石标准"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#升级模式-砖石标准"}},[a._v("#")]),a._v(" 升级模式-砖石标准")]),a._v(" "),s("h2",{attrs:{id:"升级模式-信标标准"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#升级模式-信标标准"}},[a._v("#")]),a._v(" 升级模式-信标标准")]),a._v(" "),s("h2",{attrs:{id:"升级模式-create2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#升级模式-create2"}},[a._v("#")]),a._v(" 升级模式-create2")])])}),[],!1,null,null,null);t.default=e.exports}}]);