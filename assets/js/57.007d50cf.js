(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{427:function(a,t,s){"use strict";s.r(t);var r=s(46),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"钱包的概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#钱包的概念"}},[a._v("#")]),a._v(" 钱包的概念")]),a._v(" "),s("h5",{attrs:{id:"在区块链上钱包是链上的一个账户-用于存储加密货币资产-只有拥有这个账户的《私钥》才能对资产拥有转移的权限-用私钥对交易进行签名-在链上就是消费证明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在区块链上钱包是链上的一个账户-用于存储加密货币资产-只有拥有这个账户的《私钥》才能对资产拥有转移的权限-用私钥对交易进行签名-在链上就是消费证明"}},[a._v("#")]),a._v(" "),s("span",{attrs:{id:"gonglian"}},[a._v("  在区块链上钱包是链上的一个账户，用于存储加密货币资产，只有拥有这个账户的《私钥》才能对资产拥有转移的权限（用私钥对交易进行签名），在链上就是消费证明 ")])]),a._v(" "),s("h4",{attrs:{id:"概念之间的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概念之间的关系"}},[a._v("#")]),a._v(" 概念之间的关系")]),a._v(" "),s("p",[a._v("    总之，私钥是通过椭圆曲线相乘算法来推导出共钥，而共钥通过哈希函数生成账户地址，这个俩个都是单向操作的，私\n    钥永远可以导出账户地址，而账户地址是无法推导出私钥")]),a._v(" "),s("h5",{attrs:{id:"因此-数字钱包实际是一个管理私钥-生成、存储、签名-的工具。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#因此-数字钱包实际是一个管理私钥-生成、存储、签名-的工具。"}},[a._v("#")]),a._v("     因此, 数字钱包实际是一个管理私钥（生成、存储、签名）的工具。")]),a._v(" "),s("div",{staticClass:"language-angular2 extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("                椭圆曲线相乘                     哈希函数\n                  （单向）                       （单向）\n      私钥  =====================> 共钥  =====================>  账户地址\n")])])]),s("h5",{attrs:{id:"代码实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码实现"}},[a._v("#")]),a._v("     代码实现")]),a._v(" "),s("div",{staticClass:"language-angular2 extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("import { ethers, utils } from 'ethers'\n\nlet password = 'guomingcheng1234567890'         // 使用一个密码来创建私钥，就算私钥丢弃了，也是可以通过这个密码来推导出私钥\nlet passwordBytes = utils.toUtf8Bytes(password);// 把秘密字符串转换为，字节类型，才能使用 keccak256 哈希运算\nutils.keccak256(passwordBytes)                  // 这里运算的 32 位字节，就可以用作于私钥，在以太网上进行交易以及签名\n\n// 私钥通过这个函数，可以导出公钥\nconsole.log(utils.computePublicKey(utils.keccak256(passwordBytes)))\n// 私钥或者公钥通过这个函数，可以导出账户的地址\nconsole.log(utils.computeAddress(utils.keccak256(passwordBytes)))\n\n")])])]),s("h2",{attrs:{id:"账户的创建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#账户的创建"}},[a._v("#")]),a._v(" 账户的创建")]),a._v(" "),s("h5",{attrs:{id:"创建一个账户地址关键是生成一个私钥-而私钥是一个-32-字节-64-个字符的一串字符串-因此。生成私钥是第一步也是最重要的一步-是要找到足够安全的熵源-即是随机数的来源-只要选取的结果不可预测或者不可重复的-那么选取数字的方法并不重要"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建一个账户地址关键是生成一个私钥-而私钥是一个-32-字节-64-个字符的一串字符串-因此。生成私钥是第一步也是最重要的一步-是要找到足够安全的熵源-即是随机数的来源-只要选取的结果不可预测或者不可重复的-那么选取数字的方法并不重要"}},[a._v("#")]),a._v(" "),s("span",{attrs:{id:"gonglian"}},[a._v(" 创建一个账户地址关键是生成一个私钥，而私钥是一个 32 字节，64 个字符的一串字符串，因此。生成私钥是第一步也是最重要的一步，是要找到足够安全的熵源，即是随机数的来源，只要选取的结果不可预测或者不可重复的，那么选取数字的方法并不重要 ")])]),a._v(" "),s("h2",{attrs:{id:"bip32"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bip32"}},[a._v("#")]),a._v(" BIP32")]),a._v(" "),s("h5",{attrs:{id:"钱包就是一个私钥的容器-按照上面的方法-是可也随机的生成无数个私钥-而用户备份这些私钥就显得特别麻烦-为应对这个问题-就有了-bip32-提议-根据一个随机的种子通过分层确定性的方式来得到-n-个私钥-只需要保存好这个种子-按照确定性的方式就可也推导出所有的私钥"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#钱包就是一个私钥的容器-按照上面的方法-是可也随机的生成无数个私钥-而用户备份这些私钥就显得特别麻烦-为应对这个问题-就有了-bip32-提议-根据一个随机的种子通过分层确定性的方式来得到-n-个私钥-只需要保存好这个种子-按照确定性的方式就可也推导出所有的私钥"}},[a._v("#")]),a._v(" "),s("span",{attrs:{id:"gonglian"}},[a._v(" 钱包就是一个私钥的容器，按照上面的方法，是可也随机的生成无数个私钥，而用户备份这些私钥就显得特别麻烦, 为应对这个问题，就有了 BIP32 提议：根据一个随机的种子通过分层确定性的方式来得到 n 个私钥，只需要保存好这个种子，按照确定性的方式就可也推导出所有的私钥，")])]),a._v(" "),s("h4",{attrs:{id:"关系图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关系图"}},[a._v("#")]),a._v(" 关系图")]),a._v(" "),s("p",[a._v("    这个种子可以是密码学安全的随机数，也可以是助记词，也可以熟悉的一段密码。 先通过种子来生成主密钥，在根据主\n    密钥和一个自增的数字(或者一个确定性的方式)，就生成无数个子密钥，每一个子密 钥也是可以通过这个方式来生成无\n    数个孙密钥，依次类推。")]),a._v(" "),s("h5",{attrs:{id:"所以-只需要记住种子-就可以找回所有的私钥-因为非对称加密只能单向输出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#所以-只需要记住种子-就可以找回所有的私钥-因为非对称加密只能单向输出"}},[a._v("#")]),a._v("     所以，只需要记住种子，就可以找回所有的私钥, 因为非对称加密只能单向输出")]),a._v(" "),s("div",{staticClass:"language-angular2 extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\n            \n         生成密钥                  可以生成无数\n                                   子密钥         \n种子   ------------\x3e    主密钥  -----------------\x3e    子密钥-N\n                \n                                                          \n")])])]),s("h5",{attrs:{id:"bip32-提议-为了避免管理一堆私钥的麻烦而提出的分层推导方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bip32-提议-为了避免管理一堆私钥的麻烦而提出的分层推导方案"}},[a._v("#")]),a._v("     BIP32 提议：为了避免管理一堆私钥的麻烦而提出的分层推导方案")]),a._v(" "),s("h2",{attrs:{id:"bip44"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bip44"}},[a._v("#")]),a._v(" BIP44")]),a._v(" "),s("h5",{attrs:{id:"通过这种分层-树形结构-推导出来的密钥-通常是可以用路径来表示-每个级别之间用斜杠-来表示。有主私钥衍生出来的私钥以-m-开头"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#通过这种分层-树形结构-推导出来的密钥-通常是可以用路径来表示-每个级别之间用斜杠-来表示。有主私钥衍生出来的私钥以-m-开头"}},[a._v("#")]),a._v(" "),s("span",{attrs:{id:"gonglian"}},[a._v(" 通过这种分层（树形结构）推导出来的密钥，通常是可以用路径来表示，每个级别之间用斜杠 / 来表示。有主私钥衍生出来的私钥以 m 开头**** ")])]),a._v(" "),s("h2",{attrs:{id:"bip39"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bip39"}},[a._v("#")]),a._v(" BIP39")])])}),[],!1,null,null,null);t.default=e.exports}}]);