<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>hooks 概念 | 文档</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/index.css">
    <script src="/js/index.js"></script>
    <meta name="description" content="个人文档">
    
    <link rel="preload" href="/assets/css/0.styles.8cd2006c.css" as="style"><link rel="preload" href="/assets/js/app.ce1393de.js" as="script"><link rel="preload" href="/assets/js/2.ee68cb5d.js" as="script"><link rel="preload" href="/assets/js/36.5a949c11.js" as="script"><link rel="prefetch" href="/assets/js/10.fae9557b.js"><link rel="prefetch" href="/assets/js/11.ec03d5d9.js"><link rel="prefetch" href="/assets/js/12.aa5ec6e6.js"><link rel="prefetch" href="/assets/js/13.fa27dbe3.js"><link rel="prefetch" href="/assets/js/14.27428945.js"><link rel="prefetch" href="/assets/js/15.e19dc613.js"><link rel="prefetch" href="/assets/js/16.ac5d0041.js"><link rel="prefetch" href="/assets/js/17.b015baa0.js"><link rel="prefetch" href="/assets/js/18.d790bc9c.js"><link rel="prefetch" href="/assets/js/19.7f450609.js"><link rel="prefetch" href="/assets/js/20.504a3fd4.js"><link rel="prefetch" href="/assets/js/21.fcc0c1f7.js"><link rel="prefetch" href="/assets/js/22.1e27d5c1.js"><link rel="prefetch" href="/assets/js/23.e7de804c.js"><link rel="prefetch" href="/assets/js/24.89d96b41.js"><link rel="prefetch" href="/assets/js/25.47d860f4.js"><link rel="prefetch" href="/assets/js/26.03bbdba6.js"><link rel="prefetch" href="/assets/js/27.adba25d3.js"><link rel="prefetch" href="/assets/js/28.51f6ec86.js"><link rel="prefetch" href="/assets/js/29.3d75e6eb.js"><link rel="prefetch" href="/assets/js/3.af3b0f40.js"><link rel="prefetch" href="/assets/js/30.3ea92647.js"><link rel="prefetch" href="/assets/js/31.50e89190.js"><link rel="prefetch" href="/assets/js/32.2330f5a5.js"><link rel="prefetch" href="/assets/js/33.3db8ae98.js"><link rel="prefetch" href="/assets/js/34.b38625c8.js"><link rel="prefetch" href="/assets/js/35.49492a46.js"><link rel="prefetch" href="/assets/js/37.e1595cca.js"><link rel="prefetch" href="/assets/js/38.5e66f157.js"><link rel="prefetch" href="/assets/js/39.e118d131.js"><link rel="prefetch" href="/assets/js/4.dcedff1a.js"><link rel="prefetch" href="/assets/js/40.9b43fbc7.js"><link rel="prefetch" href="/assets/js/41.d9116c83.js"><link rel="prefetch" href="/assets/js/42.95c96c90.js"><link rel="prefetch" href="/assets/js/43.a92421aa.js"><link rel="prefetch" href="/assets/js/44.e19be0d2.js"><link rel="prefetch" href="/assets/js/45.def7c4a5.js"><link rel="prefetch" href="/assets/js/46.b4d92a6e.js"><link rel="prefetch" href="/assets/js/47.de8d2dc3.js"><link rel="prefetch" href="/assets/js/48.21f95edd.js"><link rel="prefetch" href="/assets/js/49.26d21bfa.js"><link rel="prefetch" href="/assets/js/5.1bf7576d.js"><link rel="prefetch" href="/assets/js/50.1ea86b8f.js"><link rel="prefetch" href="/assets/js/51.034e7576.js"><link rel="prefetch" href="/assets/js/52.9afafe11.js"><link rel="prefetch" href="/assets/js/53.688c4d83.js"><link rel="prefetch" href="/assets/js/54.13bfb729.js"><link rel="prefetch" href="/assets/js/55.e066dc58.js"><link rel="prefetch" href="/assets/js/56.c036e408.js"><link rel="prefetch" href="/assets/js/57.007d50cf.js"><link rel="prefetch" href="/assets/js/58.3f670fa2.js"><link rel="prefetch" href="/assets/js/59.f41e8ae6.js"><link rel="prefetch" href="/assets/js/6.8cf2a95e.js"><link rel="prefetch" href="/assets/js/60.f0fda430.js"><link rel="prefetch" href="/assets/js/61.ae4987fd.js"><link rel="prefetch" href="/assets/js/62.3c3e0b82.js"><link rel="prefetch" href="/assets/js/63.87900c10.js"><link rel="prefetch" href="/assets/js/64.9ffbb746.js"><link rel="prefetch" href="/assets/js/65.52ffe053.js"><link rel="prefetch" href="/assets/js/66.0b20125c.js"><link rel="prefetch" href="/assets/js/67.cd8a1668.js"><link rel="prefetch" href="/assets/js/68.97020436.js"><link rel="prefetch" href="/assets/js/69.533a79a4.js"><link rel="prefetch" href="/assets/js/7.299203e9.js"><link rel="prefetch" href="/assets/js/70.29933dd9.js"><link rel="prefetch" href="/assets/js/71.f88421fc.js"><link rel="prefetch" href="/assets/js/72.95de2bad.js"><link rel="prefetch" href="/assets/js/73.4a4257cc.js"><link rel="prefetch" href="/assets/js/74.659aab88.js"><link rel="prefetch" href="/assets/js/75.cadd4a65.js"><link rel="prefetch" href="/assets/js/76.254b9f42.js"><link rel="prefetch" href="/assets/js/77.e5b5a87b.js"><link rel="prefetch" href="/assets/js/78.b1b2dd8d.js"><link rel="prefetch" href="/assets/js/79.cbbbe000.js"><link rel="prefetch" href="/assets/js/8.c093787a.js"><link rel="prefetch" href="/assets/js/80.2b85c169.js"><link rel="prefetch" href="/assets/js/81.c6f26762.js"><link rel="prefetch" href="/assets/js/9.010ac11f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8cd2006c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">文档</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/区块链.html" class="nav-link">
  区块链
</a></div><div class="nav-item"><a href="/英语.html" class="nav-link">
  英语
</a></div><div class="nav-item"><a href="/前端.html" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/疑问解述篇.html" class="nav-link">
  疑问解述篇
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/区块链.html" class="nav-link">
  区块链
</a></div><div class="nav-item"><a href="/英语.html" class="nav-link">
  英语
</a></div><div class="nav-item"><a href="/前端.html" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/疑问解述篇.html" class="nav-link">
  疑问解述篇
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>react</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/前端/react/react.html" class="sidebar-link">渲染章节</a></li><li><a href="/前端/react/react-01.html" class="sidebar-link">组件章节</a></li><li><a href="/前端/react/react-02.html" class="sidebar-link">组件通信章节</a></li><li><a href="/前端/react/react-hooks.html" class="active sidebar-link">hooks 章节</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/前端/react/react-hooks.html#hooks-概念" class="sidebar-link">hooks 概念</a></li><li class="sidebar-sub-header"><a href="/前端/react/react-hooks.html#usestate" class="sidebar-link">useState</a></li><li class="sidebar-sub-header"><a href="/前端/react/react-hooks.html#useeffect" class="sidebar-link">useEffect</a></li><li class="sidebar-sub-header"><a href="/前端/react/react-hooks.html#useref" class="sidebar-link">useRef</a></li><li class="sidebar-sub-header"><a href="/前端/react/react-hooks.html#usecontext" class="sidebar-link">useContext</a></li><li class="sidebar-sub-header"><a href="/前端/react/react-hooks.html#memo-usecallback" class="sidebar-link">memo, useCallback</a></li></ul></li><li><a href="/前端/react/react-redux.html" class="sidebar-link">redux 章节</a></li><li><a href="/前端/react/react-toolkit.html" class="sidebar-link">toolkit 章节</a></li><li><a href="/前端/react/react-router.html" class="sidebar-link">router 章节</a></li><li><a href="/前端/react/react-config.html" class="sidebar-link">package</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>typescript</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="hooks-概念"><a href="#hooks-概念" class="header-anchor">#</a> hooks 概念</h2> <h4 id="hooks-的出现-就是为了解决函数没有状态的问题-hooks-会使的函数组件更加强大-更为灵活的勾子"><a href="#hooks-的出现-就是为了解决函数没有状态的问题-hooks-会使的函数组件更加强大-更为灵活的勾子" class="header-anchor">#</a> hooks 的出现，就是为了解决函数没有状态的问题，hooks 会使的函数组件更加强大，更为灵活的勾子</h4> <h5 id="在-react-体现中组件分为《类组件》与《函数组件》。"><a href="#在-react-体现中组件分为《类组件》与《函数组件》。" class="header-anchor">#</a> 在 react 体现中组件分为《类组件》与《函数组件》。</h5> <h6 id="过多年的实战-函数组件是一个更加匹配-react-的设计理念-ui-fun-data-也便于逻辑逻辑拆分与重用的组件表达形式而先前的函数组件时没有自己的状态的-为了能让函数组件可以拥有自己的状态-hooks-应运而生"><a href="#过多年的实战-函数组件是一个更加匹配-react-的设计理念-ui-fun-data-也便于逻辑逻辑拆分与重用的组件表达形式而先前的函数组件时没有自己的状态的-为了能让函数组件可以拥有自己的状态-hooks-应运而生" class="header-anchor">#</a> 过多年的实战，函数组件是一个更加匹配 React 的设计理念 UI = fun(data), 也便于逻辑逻辑拆分与重用的组件表达形式而先前的函数组件时没有自己的状态的，为了能让函数组件可以拥有自己的状态，Hooks 应运而生</h6> <h4 id="注意点"><a href="#注意点" class="header-anchor">#</a> 注意点：</h4> <h6 id="_1、虽然有-hooks-但是-class-组件并没有被移除-俩者是并存的"><a href="#_1、虽然有-hooks-但是-class-组件并没有被移除-俩者是并存的" class="header-anchor">#</a>    1、虽然有 hooks, 但是 class　组件并没有被移除，俩者是并存的</h6> <h6 id="_2、在有了-hooks-之后-不能把函数再为无状态组件了-因为-hooks-为函数提供了状态"><a href="#_2、在有了-hooks-之后-不能把函数再为无状态组件了-因为-hooks-为函数提供了状态" class="header-anchor">#</a>    ２、在有了 hooks 之后，不能把函数再为无状态组件了，因为 hooks 为函数提供了状态</h6> <h6 id="_3、-hooks-只能在函数中使用"><a href="#_3、-hooks-只能在函数中使用" class="header-anchor">#</a>    3、 hooks 只能在函数中使用</h6> <h2 id="usestate"><a href="#usestate" class="header-anchor">#</a> useState</h2> <h4 id="usestate-回调函数参数"><a href="#usestate-回调函数参数" class="header-anchor">#</a> useState 回调函数参数</h4> <h6 id="语法-name-setname-usestate-编写计算逻辑-return-计算之后的初始值"><a href="#语法-name-setname-usestate-编写计算逻辑-return-计算之后的初始值" class="header-anchor">#</a> 语法: [name, setName] = useState(() =&gt; { // 编写计算逻辑，return 计算之后的初始值})</h6> <h6 id="这个回调参数也是首次渲染是才被调用-后续的渲染就会忽略-这个函数返回的数据就作为-usestate-函数的初始值。如果需要动态的计算状态的初始值-就可以通过这个方式就创建状态值"><a href="#这个回调参数也是首次渲染是才被调用-后续的渲染就会忽略-这个函数返回的数据就作为-usestate-函数的初始值。如果需要动态的计算状态的初始值-就可以通过这个方式就创建状态值" class="header-anchor">#</a> 这个回调参数也是首次渲染是才被调用，后续的渲染就会忽略，这个函数返回的数据就作为 useState() 函数的初始值。如果需要动态的计算状态的初始值，就可以通过这个方式就创建状态值</h6> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token comment">// 类组件</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span>
<span class="token comment">// useState() 是一个方法，hooks 是通过 useState 方法来维护函数组件的状态数据</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span>

<span class="token comment">// 组件的更新过程</span>
<span class="token comment">// 当调用 setCount() 函数的时候，更新过程</span>

<span class="token comment">// 渲染</span>
<span class="token comment">// 第一次渲染的时候，组件内部的代码会被执行了一次，其中 useState() 也会跟着初始化状态值</span>
<span class="token comment">// 所以 count 首次等于 useState() 传入参数的值，而通过 setCount() 函数更新状态，再次渲染，count 值就等于修改的值，不在是初始值</span>

<span class="token comment">// 重点注意:</span>
<span class="token comment">// useState() 传递的参数只会在首次渲染生效，后续只要调用 setCount() 函数，整个 App 中代码都会执行</span>
<span class="token comment">// 而此时的 count 每次拿到的都是新值</span>
<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// useState() 参数，是状态变量，可以是任意的类型，count 类型等于参数类型</span>
  <span class="token comment">// useState() 返回的是一个数组，使用解构语法分解给 count、 setCount()，</span>
  <span class="token comment">// count 是状态变量的值，相同类组件的 state 变量。 setCount() 是修改状态变量的值，相同类组件的 setState()方法一样，使用也一样</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">&quot;guomingcheng&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// useState() 函数可以执行多次，每个 useState 互相独立，又各自绑定，就相当多份状态数据</span>
  <span class="token comment">// const [flag, setFlag] = useState(flase);</span>

  <span class="token keyword">return</span><span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      App
      <span class="token punctuation">{</span>count<span class="token punctuation">.</span>name<span class="token punctuation">}</span>
      <span class="token punctuation">{</span><span class="token comment">/* 在这里使用修改状态的方法，还是需要使用 ()=&gt; 函数包裹一样 */</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'是一样的'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>更新<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>

<span class="token punctuation">}</span>


<span class="token keyword">export</span> <span class="token keyword">default</span> App

</code></pre></div><h2 id="useeffect"><a href="#useeffect" class="header-anchor">#</a> useEffect</h2> <h6 id="useeffect-也是一个函数-react-提供这个函数的用意是-用于处理其他业务逻辑。因为-react-希望一个函数组件尽可能的只处理当前组件的逻辑-但如果你真的要在这个函数组件内处理其他逻辑-react-希望把要处理其他业务逻辑的函数传递-useeffect-来执行"><a href="#useeffect-也是一个函数-react-提供这个函数的用意是-用于处理其他业务逻辑。因为-react-希望一个函数组件尽可能的只处理当前组件的逻辑-但如果你真的要在这个函数组件内处理其他逻辑-react-希望把要处理其他业务逻辑的函数传递-useeffect-来执行" class="header-anchor">#</a> useEffect 也是一个函数，react 提供这个函数的用意是，用于处理其他业务逻辑。因为 react 希望一个函数组件尽可能的只处理当前组件的逻辑，但如果你真的要在这个函数组件内处理其他逻辑，react 希望把要处理其他业务逻辑的函数传递 useEffect() 来执行</h6> <h4 id="注意"><a href="#注意" class="header-anchor">#</a> 注意：</h4> <h6 id="当在-useeffect-函数内使用到状态数据-那么就应当把这个状态数据添加到数组的依赖项种-不然会出现-bug"><a href="#当在-useeffect-函数内使用到状态数据-那么就应当把这个状态数据添加到数组的依赖项种-不然会出现-bug" class="header-anchor">#</a>     当在 useEffect() 函数内使用到状态数据，那么就应当把这个状态数据添加到数组的依赖项种，不然会出现 bug</h6> <div class="language-js extra-class"><pre class="language-js"><code>

<span class="token comment">// 类组件</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span>
<span class="token comment">// useEffect() 函数用于处理其他业务逻辑</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span>


<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">&quot;guomingcheng&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// 参数是一个函数，尽量把其他业务逻辑在这里执行</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>title <span class="token operator">=</span> count<span class="token punctuation">.</span>name
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// useEffect() 依赖性</span>
  <span class="token comment">// 第一种:</span>
  <span class="token comment">// 首次渲染执行，setCount() 更新状态变量时，会重新的渲染 App 函数，useEffect() 也会再次执行</span>
  <span class="token comment">// 第二种:</span>
  <span class="token comment">// 如果第二个参数传递一个 [] 空的数组，那么就在首次渲染执行一次</span>
  <span class="token comment">// 第三种:</span>
  <span class="token comment">// 如果第二个参数是一个特定的依赖性，如传递 [count], 那么每当 count 状态发送改变的时候，就会再次的执行 useEffect() 函数</span>
  
  <span class="token keyword">return</span><span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      App
      <span class="token punctuation">{</span>count<span class="token punctuation">.</span>name<span class="token punctuation">}</span>
      <span class="token punctuation">{</span><span class="token comment">/* 在这里使用修改状态的方法，还是需要使用 ()=&gt; 函数包裹一样 */</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'是一样的'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>更新<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>

<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App

</code></pre></div><h4 id="useeffect-的组件销毁清理"><a href="#useeffect-的组件销毁清理" class="header-anchor">#</a> useEffect 的组件销毁清理</h4> <h6 id="我们知道类组件是有生命周期的-每个阶段都会回调一个函数-如类组件的-componentwillunmount-函数-当类组件在页面上消失-都会调用这个函数。所以-在-hooks-的函数组件中也提供了这样功能-是用-useeffect-函数来实现"><a href="#我们知道类组件是有生命周期的-每个阶段都会回调一个函数-如类组件的-componentwillunmount-函数-当类组件在页面上消失-都会调用这个函数。所以-在-hooks-的函数组件中也提供了这样功能-是用-useeffect-函数来实现" class="header-anchor">#</a>      我们知道类组件是有生命周期的，每个阶段都会回调一个函数，如类组件的 componentWillUnmount() 函数，当类组件在页面上消失，都会调用这个函数。所以，在 hooks 的函数组件中也提供了这样功能，是用 useEffect() 函数来实现</h6> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 类组件</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span>
<span class="token comment">// useEffect() 函数用于处理其他业务逻辑</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span>


<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">&quot;guomingcheng&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// App 渲染是调用一次，状态更新也不会调用</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>title <span class="token operator">=</span> count<span class="token punctuation">.</span>name
    
    <span class="token comment">// 在 useEffect 函数，返回一个箭头函数类型，每当 App 组件在页面上消失，就会回调这个箭头函数。</span>
    <span class="token comment">// 这样就实现了与类组件 componentWillUnmount() 函数的功能</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  
  <span class="token keyword">return</span><span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      App
      <span class="token punctuation">{</span>count<span class="token punctuation">.</span>name<span class="token punctuation">}</span>
      <span class="token punctuation">{</span><span class="token comment">/* 在这里使用修改状态的方法，还是需要使用 ()=&gt; 函数包裹一样 */</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'是一样的'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>更新<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>

<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App

</code></pre></div><h4 id="useeffect-中请求正确的写法"><a href="#useeffect-中请求正确的写法" class="header-anchor">#</a> useEffect 中请求正确的写法</h4> <div class="language-js extra-class"><pre class="language-js"><code>    
 <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 声明异步函数</span>
    <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'http://127.0.0.1/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 调用</span>
    <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    
</code></pre></div><h2 id="useref"><a href="#useref" class="header-anchor">#</a> useRef</h2> <h6 id="这个函数的作用是-当一个组件渲染完成后-可以通过-useref-来获取一个类组件的实例-或者获取函数组件的-dom-结构"><a href="#这个函数的作用是-当一个组件渲染完成后-可以通过-useref-来获取一个类组件的实例-或者获取函数组件的-dom-结构" class="header-anchor">#</a> 这个函数的作用是，当一个组件渲染完成后，可以通过 useRef() 来获取一个类组件的实例，或者获取函数组件的 DOM 结构</h6> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token comment">// 类组件</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span>
<span class="token comment">// useEffect() 函数用于处理其他业务逻辑</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useEffect<span class="token punctuation">,</span> useRef <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>

  <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Test<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>


<span class="token keyword">function</span> <span class="token function">App</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// null 参数默认编写的规则，返回的类型，绑定组件上，就可以获取组件的实例</span>
  <span class="token comment">// useRef() 只能获取类组件的实例，与普通的 DOM 结构，useRef() 是捕获不了函数组件这个要注意</span>
  <span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> dam <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>

  <span class="token comment">// dom 首次渲染完成后，会调用这个</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// test.current 就是 Test 类组件的实例，可以操作 Test 组件的《 函数，状态 》</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>current<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dam<span class="token punctuation">.</span>current<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span><span class="token comment">/*  这里的意思就是，通过 ref={test} 绑定 Test, 就会捕获类组件的实例 */</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>Test ref<span class="token operator">=</span><span class="token punctuation">{</span>test<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>p ref<span class="token operator">=</span><span class="token punctuation">{</span>dam<span class="token punctuation">}</span><span class="token operator">&gt;</span>a<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button <span class="token operator">&gt;</span>更新<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>

<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App

</code></pre></div><h2 id="usecontext"><a href="#usecontext" class="header-anchor">#</a> useContext</h2> <h6 id="这个函数也是实现跨组件通信"><a href="#这个函数也是实现跨组件通信" class="header-anchor">#</a> 这个函数也是实现跨组件通信</h6> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token comment">// useEffect() 函数用于处理其他业务逻辑</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createContext<span class="token punctuation">,</span> useContext<span class="token punctuation">,</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span>

<span class="token comment">// 使用 useCntext() 实现跨组件通信还是需要使用 creacteContext() 函数</span>
<span class="token keyword">const</span> Context <span class="token operator">=</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ComA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// useContext 函数参数一定是 Context, 这样就能获取父组件通过 Context 对象传递的数据，这个数据也是响应式的</span>
  <span class="token comment">// 每个子组件都可以通过 useContext() 函数，来获取父组件传递的数据</span>
  <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>Context<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>count<span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">App</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token comment">// 父组件传递数据，也是需要使用这个标签包裹起来, 同样使用 value 属性传递</span>
    <span class="token operator">&lt;</span>Context<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>ComA<span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span> 点击<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>Context<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>

  <span class="token punctuation">)</span>

<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App

</code></pre></div><h2 id="memo-usecallback"><a href="#memo-usecallback" class="header-anchor">#</a> memo, useCallback</h2> <h5 id="在-react-组件渲染中-只要父组件的一个状态发生了修改-那么就会重新的渲染当前组件的所以子组件-也就是说-子组件就算没有使用了状态变量-也是发生了重新渲染。"><a href="#在-react-组件渲染中-只要父组件的一个状态发生了修改-那么就会重新的渲染当前组件的所以子组件-也就是说-子组件就算没有使用了状态变量-也是发生了重新渲染。" class="header-anchor">#</a> 在 react 组件渲染中，只要父组件的一个状态发生了修改，那么就会重新的渲染当前组件的所以子组件，也就是说，子组件就算没有使用了状态变量，也是发生了重新渲染。</h5> <h5 id="这个就产生了性能问题-因为如果一个子组件没有使用到状态变量-那么这个组件只需要渲染一次即可-所以要使用-react-提供的-memo-与-usecallback-函数-这俩个函数一般是配合使用的"><a href="#这个就产生了性能问题-因为如果一个子组件没有使用到状态变量-那么这个组件只需要渲染一次即可-所以要使用-react-提供的-memo-与-usecallback-函数-这俩个函数一般是配合使用的" class="header-anchor">#</a> 这个就产生了性能问题，因为如果一个子组件没有使用到状态变量，那么这个组件只需要渲染一次即可，所以要使用 react 提供的 memo 与 useCallback 函数，这俩个函数一般是配合使用的</h5> <h6 id="第一种情况"><a href="#第一种情况" class="header-anchor">#</a> 第一种情况：</h6> <h6 id="子组件并没有使用-status-变量-也没有使用修改-status-变量函数-这个也是纯静态组件"><a href="#子组件并没有使用-status-变量-也没有使用修改-status-变量函数-这个也是纯静态组件" class="header-anchor">#</a> 子组件并没有使用 status 变量，也没有使用修改 status 变量函数，这个也是纯静态组件</h6> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">import</span> <span class="token punctuation">{</span> memo<span class="token punctuation">,</span> useCallback<span class="token punctuation">,</span> useEffect<span class="token punctuation">,</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">import</span> <span class="token string">'./App.css'</span>

<span class="token comment">// 这样的纯静态组件就不能使用 function 函数来编写</span>
<span class="token comment">// 要使用 ()=&gt; 箭头语法来编写，把组件的内容编写在 memo() 函数内，就可以，这样父组件发生了修改，也不会重新渲染 Comm 组件</span>
<span class="token keyword">const</span> Comm <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span>props<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token function-variable function">increment</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'不会渲染'</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span><span class="token number">121</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
  <span class="token comment">// 这里的状态变量发生了变化，是不会重新渲染子组件的</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> useState<span class="token operator">&lt;</span>number<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;App&quot;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>内部点击<span class="token operator">&lt;</span><span class="token operator">/</span>butto<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Comm<span class="token operator">/</span><span class="token operator">&gt;</span>  
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App


</code></pre></div><h6 id="第二种情况"><a href="#第二种情况" class="header-anchor">#</a> 第二种情况：</h6> <h6 id="子组件虽然没有使用-status-状态变量-但是需要使用到修改状态变量的函数-这也称为半静态函数"><a href="#子组件虽然没有使用-status-状态变量-但是需要使用到修改状态变量的函数-这也称为半静态函数" class="header-anchor">#</a> 子组件虽然没有使用 status 状态变量，但是需要使用到修改状态变量的函数，这也称为半静态函数</h6> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">import</span> <span class="token punctuation">{</span> memo<span class="token punctuation">,</span> useCallback<span class="token punctuation">,</span> useEffect<span class="token punctuation">,</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>

<span class="token comment">// 这个需要 memo 与 useCallback() 函数配合使用</span>
<span class="token comment">// 这里 button 就使用了修改状态的函数，如果不使用 useCallback() 来包装修改状态的函数，一旦父组件有任何的状态变动，就会重新渲染子组件</span>
<span class="token comment">// 但是用的 useCallback() 包装，只有当检测到状态的变动才会重新渲染子组件，父组件其他状态发生变化是不会渲染这个子组件的</span>
<span class="token keyword">const</span> Comm <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>props<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token function-variable function">toggle</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'中间件'</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> props<span class="token punctuation">.</span><span class="token function">toggle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>子组件点击<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> useState<span class="token operator">&lt;</span>number<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

  <span class="token comment">// 这里就是 useCallback() 函数包装了，并检测 count 状态</span>
  <span class="token comment">// 如果 count 状态发生变动，任何使用到 toggleCount() 函数的子组件都会重新渲染  </span>
  <span class="token keyword">const</span> toggleCount <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;App&quot;</span><span class="token operator">&gt;</span>
    
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>内部点击<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Comm toggle<span class="token operator">=</span><span class="token punctuation">{</span>toggleCount<span class="token punctuation">}</span> count<span class="token operator">=</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/前端/react/react-02.html" class="prev">
        组件通信章节
      </a></span> <span class="next"><a href="/前端/react/react-redux.html">
        redux 章节
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ce1393de.js" defer></script><script src="/assets/js/2.ee68cb5d.js" defer></script><script src="/assets/js/36.5a949c11.js" defer></script>
  </body>
</html>
