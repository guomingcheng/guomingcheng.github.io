<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>简介 | 文档</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/index.css">
    <script src="/js/index.js"></script>
    <meta name="description" content="个人文档">
    
    <link rel="preload" href="/assets/css/0.styles.8cd2006c.css" as="style"><link rel="preload" href="/assets/js/app.ce1393de.js" as="script"><link rel="preload" href="/assets/js/2.ee68cb5d.js" as="script"><link rel="preload" href="/assets/js/59.f41e8ae6.js" as="script"><link rel="prefetch" href="/assets/js/10.fae9557b.js"><link rel="prefetch" href="/assets/js/11.ec03d5d9.js"><link rel="prefetch" href="/assets/js/12.aa5ec6e6.js"><link rel="prefetch" href="/assets/js/13.fa27dbe3.js"><link rel="prefetch" href="/assets/js/14.27428945.js"><link rel="prefetch" href="/assets/js/15.e19dc613.js"><link rel="prefetch" href="/assets/js/16.ac5d0041.js"><link rel="prefetch" href="/assets/js/17.b015baa0.js"><link rel="prefetch" href="/assets/js/18.d790bc9c.js"><link rel="prefetch" href="/assets/js/19.7f450609.js"><link rel="prefetch" href="/assets/js/20.504a3fd4.js"><link rel="prefetch" href="/assets/js/21.fcc0c1f7.js"><link rel="prefetch" href="/assets/js/22.1e27d5c1.js"><link rel="prefetch" href="/assets/js/23.e7de804c.js"><link rel="prefetch" href="/assets/js/24.89d96b41.js"><link rel="prefetch" href="/assets/js/25.47d860f4.js"><link rel="prefetch" href="/assets/js/26.03bbdba6.js"><link rel="prefetch" href="/assets/js/27.adba25d3.js"><link rel="prefetch" href="/assets/js/28.51f6ec86.js"><link rel="prefetch" href="/assets/js/29.3d75e6eb.js"><link rel="prefetch" href="/assets/js/3.af3b0f40.js"><link rel="prefetch" href="/assets/js/30.3ea92647.js"><link rel="prefetch" href="/assets/js/31.50e89190.js"><link rel="prefetch" href="/assets/js/32.2330f5a5.js"><link rel="prefetch" href="/assets/js/33.3db8ae98.js"><link rel="prefetch" href="/assets/js/34.b38625c8.js"><link rel="prefetch" href="/assets/js/35.49492a46.js"><link rel="prefetch" href="/assets/js/36.5a949c11.js"><link rel="prefetch" href="/assets/js/37.e1595cca.js"><link rel="prefetch" href="/assets/js/38.5e66f157.js"><link rel="prefetch" href="/assets/js/39.e118d131.js"><link rel="prefetch" href="/assets/js/4.dcedff1a.js"><link rel="prefetch" href="/assets/js/40.9b43fbc7.js"><link rel="prefetch" href="/assets/js/41.d9116c83.js"><link rel="prefetch" href="/assets/js/42.95c96c90.js"><link rel="prefetch" href="/assets/js/43.a92421aa.js"><link rel="prefetch" href="/assets/js/44.e19be0d2.js"><link rel="prefetch" href="/assets/js/45.def7c4a5.js"><link rel="prefetch" href="/assets/js/46.b4d92a6e.js"><link rel="prefetch" href="/assets/js/47.de8d2dc3.js"><link rel="prefetch" href="/assets/js/48.21f95edd.js"><link rel="prefetch" href="/assets/js/49.26d21bfa.js"><link rel="prefetch" href="/assets/js/5.1bf7576d.js"><link rel="prefetch" href="/assets/js/50.1ea86b8f.js"><link rel="prefetch" href="/assets/js/51.034e7576.js"><link rel="prefetch" href="/assets/js/52.9afafe11.js"><link rel="prefetch" href="/assets/js/53.688c4d83.js"><link rel="prefetch" href="/assets/js/54.13bfb729.js"><link rel="prefetch" href="/assets/js/55.e066dc58.js"><link rel="prefetch" href="/assets/js/56.c036e408.js"><link rel="prefetch" href="/assets/js/57.007d50cf.js"><link rel="prefetch" href="/assets/js/58.3f670fa2.js"><link rel="prefetch" href="/assets/js/6.8cf2a95e.js"><link rel="prefetch" href="/assets/js/60.f0fda430.js"><link rel="prefetch" href="/assets/js/61.ae4987fd.js"><link rel="prefetch" href="/assets/js/62.3c3e0b82.js"><link rel="prefetch" href="/assets/js/63.87900c10.js"><link rel="prefetch" href="/assets/js/64.9ffbb746.js"><link rel="prefetch" href="/assets/js/65.52ffe053.js"><link rel="prefetch" href="/assets/js/66.0b20125c.js"><link rel="prefetch" href="/assets/js/67.cd8a1668.js"><link rel="prefetch" href="/assets/js/68.97020436.js"><link rel="prefetch" href="/assets/js/69.533a79a4.js"><link rel="prefetch" href="/assets/js/7.299203e9.js"><link rel="prefetch" href="/assets/js/70.29933dd9.js"><link rel="prefetch" href="/assets/js/71.f88421fc.js"><link rel="prefetch" href="/assets/js/72.95de2bad.js"><link rel="prefetch" href="/assets/js/73.4a4257cc.js"><link rel="prefetch" href="/assets/js/74.659aab88.js"><link rel="prefetch" href="/assets/js/75.cadd4a65.js"><link rel="prefetch" href="/assets/js/76.254b9f42.js"><link rel="prefetch" href="/assets/js/77.e5b5a87b.js"><link rel="prefetch" href="/assets/js/78.b1b2dd8d.js"><link rel="prefetch" href="/assets/js/79.cbbbe000.js"><link rel="prefetch" href="/assets/js/8.c093787a.js"><link rel="prefetch" href="/assets/js/80.2b85c169.js"><link rel="prefetch" href="/assets/js/81.c6f26762.js"><link rel="prefetch" href="/assets/js/9.010ac11f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8cd2006c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">文档</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/区块链.html" class="nav-link">
  区块链
</a></div><div class="nav-item"><a href="/英语.html" class="nav-link">
  英语
</a></div><div class="nav-item"><a href="/前端.html" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/疑问解述篇.html" class="nav-link">
  疑问解述篇
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/区块链.html" class="nav-link">
  区块链
</a></div><div class="nav-item"><a href="/英语.html" class="nav-link">
  英语
</a></div><div class="nav-item"><a href="/前端.html" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/疑问解述篇.html" class="nav-link">
  疑问解述篇
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>以太坊</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/区块链/以太坊/以太坊-0001.html" class="sidebar-link">概念</a></li><li><a href="/区块链/以太坊/solidity.html" class="active sidebar-link">solidity</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#hellowrod" class="sidebar-link">HelloWrod</a></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#状态变量" class="sidebar-link">状态变量</a></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#以太单位" class="sidebar-link">以太单位</a></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#函数修饰符" class="sidebar-link">函数修饰符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#view" class="sidebar-link">view</a></li></ul></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#全局变量-msg" class="sidebar-link">全局变量 msg</a></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#默认值与常量-constant" class="sidebar-link">默认值与常量 constant</a></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#报错控制-error" class="sidebar-link">报错控制 error</a></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#修改器-modifion" class="sidebar-link">修改器 modifion</a></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#数组-array" class="sidebar-link">数组 Array</a></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#事件-event" class="sidebar-link">事件 Event</a></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#继承之间的关系顺序" class="sidebar-link">继承之间的关系顺序</a></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#支付函数-payable" class="sidebar-link">支付函数 payable</a></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#合约调用-call" class="sidebar-link">合约调用 call</a></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#哈希运算" class="sidebar-link">哈希运算</a></li><li class="sidebar-sub-header"><a href="/区块链/以太坊/solidity.html#合约验证签名" class="sidebar-link">合约验证签名</a></li></ul></li><li><a href="/区块链/以太坊/web3.0.html" class="sidebar-link">web3</a></li><li><a href="/区块链/以太坊/ethers.html" class="sidebar-link">ethers</a></li><li><a href="/区块链/以太坊/keystore 私钥加密.html" class="sidebar-link">keystore 私钥加密</a></li><li><a href="/区块链/以太坊/open 升级合约.html" class="sidebar-link">open 升级合约</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>配置</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>交易所</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h2> <h4 id="solidity-是一个支持编写多种平台链的智能合约编程语言"><a href="#solidity-是一个支持编写多种平台链的智能合约编程语言" class="header-anchor">#</a> <div class="biaoti2"></div>solidity 是一个支持编写多种平台链的智能合约编程语言</h4> <blockquote><blockquote><p>solidity 不仅是 EHT 的智能合约编程语言，同样也是一个广泛的适用于别的区块链的智能合约编程语言</p></blockquote></blockquote> <h2 id="hellowrod"><a href="#hellowrod" class="header-anchor">#</a> HelloWrod</h2> <h4 id="使用-solidity-编写一个-世界-你好"><a href="#使用-solidity-编写一个-世界-你好" class="header-anchor">#</a> <div class="biaoti2"></div> 使用 solidity 编写一个 “世界，你好”</h4> <blockquote><p>当把这个程序部署到区块链上，这个智能合约就生效了</p> <blockquote><div class="language-js extra-class"><pre class="language-js"><code>pragma solidity <span class="token operator">^</span><span class="token number">0.5</span><span class="token number">.3</span><span class="token punctuation">;</span> <span class="token comment">// 声明智能合约的编译版本， ^ 标识符表示编译器不能低于 0.5.3 </span>

<span class="token comment">// contract 是声明一个类，与 java class 同等效果</span>
contract Hello<span class="token punctuation">{</span>
   
   <span class="token comment">//声明一个变量， public 表示该变量是可以被外界访问的</span>
   string <span class="token keyword">public</span> greet <span class="token operator">=</span> <span class="token string">&quot;Hello Word&quot;</span><span class="token punctuation">;</span>
   
<span class="token punctuation">}</span>
</code></pre></div></blockquote></blockquote> <h2 id="状态变量"><a href="#状态变量" class="header-anchor">#</a> 状态变量</h2> <h4 id="一个永久的存储在区块链的上的数据文本"><a href="#一个永久的存储在区块链的上的数据文本" class="header-anchor">#</a> <div class="biaoti2"></div> 一个永久的存储在区块链的上的数据文本</h4> <blockquote><p>在 solidity 中，参数的状态分别使用 memory storage 俩个关键字表示， memory 表示值类型，值之间的传递是拷贝一份。 storage 表示指针类型，值之间的传递是共同指向同一个值。
<br> <br>
在类中声明的变量默认 storage 类型（不包含函数内部），而函数的参数声明以及内部变量声明都是 memory 类型</p></blockquote> <h2 id="以太单位"><a href="#以太单位" class="header-anchor">#</a> 以太单位</h2> <h2 id="函数修饰符"><a href="#函数修饰符" class="header-anchor">#</a> 函数修饰符</h2> <h4 id="view-与-pure-声明当前函数对-storage-值的操作范围"><a href="#view-与-pure-声明当前函数对-storage-值的操作范围" class="header-anchor">#</a> <div class="biaoti2"></div> view  与 pure 声明当前函数对 storage 值的操作范围</h4> <blockquote><h3 id="view"><a href="#view" class="header-anchor">#</a> view</h3> <blockquote><p>view 是修饰函数的关键字，表示该函数对 storage 值的操作范围只能是 读取</p></blockquote> <div class="custom-block tip"><p class="custom-block-title">pure</p> <div class="language- extra-class"><pre><code>pure 是修饰函数的关键字，表示该函数对 storage 值的操作范围不能读取与写入
</code></pre></div><p>s</p></div></blockquote> <h2 id="全局变量-msg"><a href="#全局变量-msg" class="header-anchor">#</a> 全局变量 msg</h2> <h4 id="以太坊虚拟机提供了的上下文对象-用于全局皆可访问"><a href="#以太坊虚拟机提供了的上下文对象-用于全局皆可访问" class="header-anchor">#</a> <div class="biaoti2"></div> 以太坊虚拟机提供了的上下文对象，用于全局皆可访问</h4> <h5 id="msg-sender-表明是上一个调用当前合约的地址-也许是用户的地址-也有可能是一个合约地址"><a href="#msg-sender-表明是上一个调用当前合约的地址-也许是用户的地址-也有可能是一个合约地址" class="header-anchor">#</a> msg.sender 表明是上一个调用当前合约的地址，也许是用户的地址，也有可能是一个合约地址</h5> <h5 id="block-timestamp-区块链的时间戳-单位是秒。注意的地方是写入区块链-不是当前时间-而是根据出块的时间来写入"><a href="#block-timestamp-区块链的时间戳-单位是秒。注意的地方是写入区块链-不是当前时间-而是根据出块的时间来写入" class="header-anchor">#</a> block.timestamp 区块链的时间戳，单位是秒。注意的地方是写入区块链，不是当前时间，而是根据出块的时间来写入</h5> <h5 id="block-number-当前区块链的高度"><a href="#block-number-当前区块链的高度" class="header-anchor">#</a> block.number 当前区块链的高度</h5> <blockquote><div class="language-js extra-class"><pre class="language-js"><code>pragma solidity <span class="token operator">^</span><span class="token number">0.8</span><span class="token number">.1</span><span class="token punctuation">;</span>

contract OverallSituation<span class="token punctuation">{</span>

   <span class="token keyword">function</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> view <span class="token function">returns</span><span class="token punctuation">(</span><span class="token parameter">address <span class="token punctuation">,</span> uint <span class="token punctuation">,</span> uint</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//在 solidity 中是可以返回多个参数的</span>
       address ddr <span class="token operator">=</span> msg<span class="token punctuation">.</span>sender<span class="token punctuation">;</span>     <span class="token comment">// 调用当前函数的地址</span>
       uint time <span class="token operator">=</span> block<span class="token punctuation">.</span>timestamp<span class="token punctuation">;</span>     <span class="token comment">//读取区块链的时间戳</span>
       uint _block <span class="token operator">=</span> block<span class="token punctuation">.</span>number<span class="token punctuation">;</span>  <span class="token comment">//区块的高度</span>

       <span class="token keyword">return</span> <span class="token punctuation">(</span>ddr<span class="token punctuation">,</span> time <span class="token punctuation">,</span> _block<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote> <h2 id="默认值与常量-constant"><a href="#默认值与常量-constant" class="header-anchor">#</a> 默认值与常量 constant</h2> <h4 id="这是-solidity-定义后的状态变量与局部变量默认的赋值"><a href="#这是-solidity-定义后的状态变量与局部变量默认的赋值" class="header-anchor">#</a> <div class="biaoti2"></div> 这是 solidity 定义后的状态变量与局部变量默认的赋值</h4> <blockquote><p>如果一个变量的值是不会变的，那么建议定义为常量。因为在( 写入方法 ) 中如果需要读这个变量的来运行操作类的话，GAS 费比不是普通变量的 GAS 费低了 15% 左右
<br><br>
** 定义一个常量需要添加 constant **</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>
pragma solidity <span class="token operator">^</span><span class="token number">0.8</span><span class="token number">.0</span><span class="token punctuation">;</span>

contract DefaultValues<span class="token punctuation">{</span>
    
    <span class="token comment">//有种常量是部署合约的时候定义，这个就需要使用 immutable 关键字标记，对于普通的变量也是节约 gas 的</span>
    address <span class="token keyword">public</span> immutable owner <span class="token operator">=</span> msg<span class="token punctuation">.</span>sender<span class="token punctuation">;</span>

    bool <span class="token keyword">public</span> b<span class="token punctuation">;</span>  <span class="token comment">// false</span>
    uint <span class="token keyword">public</span> u<span class="token punctuation">;</span>  <span class="token comment">// 0</span>
    int <span class="token keyword">public</span> i<span class="token punctuation">;</span>   <span class="token comment">// 0;</span>

    address <span class="token keyword">public</span> constant <span class="token constant">MY_ADDRESS</span><span class="token punctuation">;</span>    <span class="token comment">// 0x0000000000000000000000000000000000000000000000</span>
    bytes32 <span class="token keyword">public</span> b32<span class="token punctuation">;</span>  <span class="token comment">// 0x00000000000000000000000000000000000000000000000000000000000000000000000</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="报错控制-error"><a href="#报错控制-error" class="header-anchor">#</a> 报错控制 error</h2> <blockquote><p>** 自定义报错信息，是 0.8 新出的特性 **</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>pragma solidity <span class="token operator">^</span><span class="token number">0.8</span><span class="token number">.0</span><span class="token punctuation">;</span>

contract Errors<span class="token punctuation">{</span>

    <span class="token keyword">function</span> <span class="token function">testRevert</span><span class="token punctuation">(</span><span class="token parameter">uint _i</span><span class="token punctuation">)</span> <span class="token keyword">public</span> pure<span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>_i <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">revert</span><span class="token punctuation">(</span><span class="token string">&quot;error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//如果 _i 小于 10，就会弹出错误信息；</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">testRequire</span><span class="token punctuation">(</span><span class="token parameter">uint256 _i</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">{</span>
        <span class="token function">require</span><span class="token punctuation">(</span>_i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">&quot;error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// require 算是 testRevert 的简写，具备了小于 10， 就会弹出报错信息</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//使用 require 需要弹出的报错信息很长的话，建议使用这个自定义错误，不仅能节省 GAS ,还能弹出更详细的信息</span>
    error <span class="token function">MyError</span><span class="token punctuation">(</span>address _addr<span class="token punctuation">)</span><span class="token punctuation">;</span> 

    <span class="token keyword">function</span> <span class="token function">testCustomError</span><span class="token punctuation">(</span><span class="token parameter">uint _i</span><span class="token punctuation">)</span> <span class="token keyword">public</span> view<span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>_i <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            revert <span class="token function">MyError</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 使用自定义错误</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="修改器-modifion"><a href="#修改器-modifion" class="header-anchor">#</a> 修改器 modifion</h2> <blockquote><p>函数修改器一般用于判断，或者说是拦截器，当只有满足了条件才能放行。当调用 incBy 函数时会先进入 cap 修改器内执行，当满足了 require 的条件才执行 _; == incBY 函数体
<br><br></p> <p>** 使用 modifier 关键字来定义 **</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>pragma solidity <span class="token operator">^</span><span class="token number">0.8</span><span class="token number">.0</span><span class="token punctuation">;</span>

contract FunctionModifier<span class="token punctuation">{</span>

    modifier <span class="token function">cap</span><span class="token punctuation">(</span><span class="token parameter">uint256 _X</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment">//定义函数修改器</span>
        <span class="token function">require</span><span class="token punctuation">(</span>_X <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        _<span class="token punctuation">;</span>   <span class="token comment">//这里 == incBy 函数体  </span>
    <span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">incBy</span><span class="token punctuation">(</span><span class="token parameter">uint256 _x</span><span class="token punctuation">)</span> external pure <span class="token function">cap</span><span class="token punctuation">(</span>_x<span class="token punctuation">)</span> <span class="token function">returns</span><span class="token punctuation">(</span><span class="token parameter">uint256</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment">//使用函数修改器</span>
        <span class="token keyword">return</span> _x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="数组-array"><a href="#数组-array" class="header-anchor">#</a> 数组 Array</h2> <div class="language-js extra-class"><pre class="language-js"><code>pragma solidity <span class="token operator">^</span><span class="token number">0.8</span><span class="token number">.3</span><span class="token punctuation">;</span>

contract Array<span class="token punctuation">{</span>

    uint<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">public</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//这是一个变长数组的定义，并初始化值</span>
    uint<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token keyword">public</span> numsFixed <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">examples</span><span class="token punctuation">(</span><span class="token punctuation">)</span> external<span class="token punctuation">{</span>
        nums<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//因为 unums 定义的是变长数组，往数组 push 是没有问题的</span>
        <span class="token keyword">delete</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 删除 1 下标的元素，但是数组的长度是没有变的，只是把 1 下标的值变为 0</span>
        nums<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//弹出，这样就是删除了最后一个下标的值，数组长度也 - 1；</span>

        <span class="token comment">//在函数内定义的数组只能是定长数组，而且也不能使用 push pop 方法, 因为会改变数组的长度</span>
        uint<span class="token punctuation">[</span><span class="token punctuation">]</span> memory a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">uint</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="事件-event"><a href="#事件-event" class="header-anchor">#</a> 事件 Event</h2> <blockquote><p>定义事件需要注意的一个事件是，他是最多包含 3 个 indexed 的索引，如果一个事件的索引超出了 3 个，不然会报错的</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>pragma solidity <span class="token operator">^</span><span class="token number">0.8</span><span class="token number">.0</span><span class="token punctuation">;</span>

contract Event<span class="token punctuation">{</span>

    event <span class="token function">Log</span><span class="token punctuation">(</span>string message<span class="token punctuation">,</span> uint val<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">//定义一个事件，事件触发时，会在浏览器的 log 中显示出来</span>
    event <span class="token function">IndexedLog</span><span class="token punctuation">(</span>address indexed sender<span class="token punctuation">,</span> uint val<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//使用 indexed 标记的变量就可以被链外来搜索查询了 </span>

    <span class="token keyword">function</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> external<span class="token punctuation">{</span>
        emit <span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">&quot;from&quot;</span> <span class="token punctuation">,</span> <span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        emit <span class="token function">IndexedLog</span><span class="token punctuation">(</span> msg<span class="token punctuation">.</span>sender <span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//使用事件都是一样的</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="继承之间的关系顺序"><a href="#继承之间的关系顺序" class="header-anchor">#</a> 继承之间的关系顺序</h2> <div class="language-js extra-class"><pre class="language-js"><code>pragma solidity <span class="token operator">^</span><span class="token number">0.8</span><span class="token number">.0</span><span class="token punctuation">;</span>

contract <span class="token constant">A</span><span class="token punctuation">{</span>
    
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">string memory _text</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

    使用 virtual 标志的方法，表示可以被重写的
    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> pure virtual <span class="token function">returns</span><span class="token punctuation">(</span><span class="token parameter">string memory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;A&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
contract <span class="token constant">B</span> is <span class="token constant">A</span><span class="token punctuation">{</span>   

    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">string memory _text</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    使用 override 标志的方法，表示覆盖掉父类同名的方法
    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> pure virtual override <span class="token function">returns</span><span class="token punctuation">(</span><span class="token parameter">string memory</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;B&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
contract <span class="token constant">C</span> is <span class="token constant">A</span><span class="token punctuation">(</span><span class="token string">&quot;向 A 父类构造函数传递函数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">{</span>  <span class="token comment">//这是第一种的向基类合约传递参数</span>
    
    <span class="token function">constructor</span><span class="token punctuation">(</span>string memory _text<span class="token punctuation">)</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token parameter">_text</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">// 这个第二中向基类合约传递参数，这种一般用于动态参数</span>
    
    <span class="token punctuation">}</span>

    在继承多个合约的情况下，继承的规则是<span class="token operator">:</span> 依赖的合约最少的排在前面，以此类推
    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> pure <span class="token function">override</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token constant">B</span><span class="token punctuation">)</span> <span class="token function">returns</span><span class="token punctuation">(</span><span class="token parameter">string memory</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        string memory _bar <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用基类的合约，从继续关系最为靠近的一层开始找，找到 bar() 方法就返回。比如这个调用的是 B 合约的方法</span>
        string memory _bar2 <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//如果要明确的调用那个父合约的方法, 可以直接的合约名 A 调用 </span>

        <span class="token keyword">return</span> <span class="token string">&quot;C&quot;</span><span class="token punctuation">;</span>           如果继承的俩个合同都 pure 方法，重写必须这样写的 <span class="token function">override</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token constant">B</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="支付函数-payable"><a href="#支付函数-payable" class="header-anchor">#</a> 支付函数 payable</h2> <blockquote><p>solidity 提供了俩个 fallback receive 俩个回退函数，都是可以接受主币的，这俩个区别在于当调用者携带 data 时，就会调用 fallback, 但是如果不携带 data 就会调用 receive() 函数
。但是如果 receive() 函数没有声明，那么就会调用 fallback 函数
<br><br>
** 关键字 fallback receive **</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>pragma solidity <span class="token operator">^</span><span class="token number">0.8</span><span class="token number">.1</span><span class="token punctuation">;</span>

contract Payable<span class="token punctuation">{</span>

    address payable <span class="token keyword">public</span> owner<span class="token punctuation">;</span>  <span class="token comment">// 定义一个 payable 类型，这种类型是可以支付 eth 的</span>

    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        owner <span class="token operator">=</span> <span class="token function">payable</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//msg.sender 默认不是 payable 类型，需要来个显示类型的转换</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 回退函数，当外部调用当前合约不存在的函数时，就会执行 fallback 回退函数，当声明为 payable 就表示能主币</span>
    <span class="token function">fallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> external payable<span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> external payable<span class="token punctuation">{</span>
        <span class="token comment">//gasleft() 可以读取发送者调用函数或者发送主币携带的 gas 还剩余多少</span>
        emit <span class="token function">Log</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token function">gasleft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> external view <span class="token function">returns</span><span class="token punctuation">(</span><span class="token parameter">uint</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        owner<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token number">1</span> eth<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// transfer 只携带 2300 gas, 如果耗尽就会报错,并终止   程序运行并回滚</span>
        bool sent <span class="token operator">=</span> owner<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token number">2123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 一样是携带 2300 gas 发送主币，但是他执行成功会返回 rtue, 失败返回 false</span>
        <span class="token comment">//使用 call 发送主币， gas 多少就可以自己定义, 执行成功返回 true, byte32 是 call 调用的是函数，返回值就会在 bytes 中</span>
        <span class="token punctuation">(</span>bool success<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span> <span class="token operator">=</span> owner<span class="token punctuation">.</span>call<span class="token punctuation">{</span>value<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span> gas<span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">return</span> <span class="token function">address</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span>balance<span class="token punctuation">;</span>  <span class="token comment">//读取当前合约持有多少 eth</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="合约调用-call"><a href="#合约调用-call" class="header-anchor">#</a> 合约调用 call</h2> <blockquote><p>在一个合约中调用另一个合约有一下几种方法:
<br><br>
合约名称 : 这种不太常用，一般是在自己编写的合约调用自己另一个合约。如果想调用别人的合约就要看下了 <br>
接口合约 : 调用别人的合约，一般使用接口，只需要把调用的函数抽象为接口即可</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>pragma solidity <span class="token operator">^</span><span class="token number">0.8</span><span class="token number">.0</span><span class="token punctuation">;</span>

contract TestCall<span class="token punctuation">{</span>

    <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">string memory _message<span class="token punctuation">,</span> uint _x</span><span class="token punctuation">)</span> external pure <span class="token function">returns</span><span class="token punctuation">(</span><span class="token parameter">bool<span class="token punctuation">,</span> uint</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

contract Call<span class="token punctuation">{</span>

    bytes <span class="token keyword">public</span> data<span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">callFoo</span><span class="token punctuation">(</span><span class="token parameter">address _test</span><span class="token punctuation">)</span> external<span class="token punctuation">{</span>
        <span class="token function">require</span><span class="token punctuation">(</span>_test<span class="token punctuation">.</span>code<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//如果 &lt;= 0 , 那么表示这个地址不是合约地址</span>
        <span class="token comment">// success 表示调用是否成功</span>
        <span class="token comment">// data 是存放调用合约函数的返回值，返回的值会存放在 data 中</span>
        <span class="token punctuation">(</span>bool success<span class="token punctuation">,</span> bytes memory _data<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">_test</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>
            abi<span class="token punctuation">.</span><span class="token function">encodeWithSignature</span><span class="token punctuation">(</span><span class="token string">&quot;foo(string,uint256)&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;foo&quot;</span> <span class="token punctuation">,</span> <span class="token number">999</span>         <span class="token comment">//这是接口以及传入接口的参数，编译成二进制字节码，call 就可以调用了</span>
        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        data <span class="token operator">=</span> _data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//这是委托调用，我也看用处在哪里</span>
    <span class="token keyword">function</span> <span class="token function">setVars</span><span class="token punctuation">(</span><span class="token parameter">address _test<span class="token punctuation">,</span> uint _num</span><span class="token punctuation">)</span> external payable<span class="token punctuation">{</span>
       <span class="token punctuation">(</span>bool success<span class="token punctuation">,</span> bytes memory data<span class="token punctuation">)</span> <span class="token operator">=</span>  _test<span class="token punctuation">.</span><span class="token function">delegatecall</span><span class="token punctuation">(</span>
                <span class="token comment">//TestCall.foo.selector  ==  bytes4(keccak256(bytes(&quot;foo(string,uint256)&quot;)));</span>
                <span class="token comment">//上行的俩种方式，都是获取一个函数的哈希后的前四位字节</span>
           abi<span class="token punctuation">.</span><span class="token function">encodeWithSelector</span><span class="token punctuation">(</span>TestCall<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>selector<span class="token punctuation">,</span> _num<span class="token punctuation">)</span>  <span class="token comment">//与上面的编码是等价的</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="哈希运算"><a href="#哈希运算" class="header-anchor">#</a> 哈希运算</h2> <div class="language-js extra-class"><pre class="language-js"><code>pragma solidity <span class="token operator">^</span><span class="token number">0.8</span><span class="token number">.0</span><span class="token punctuation">;</span>

contract HashFun<span class="token punctuation">{</span>

    <span class="token keyword">function</span> <span class="token function">encode</span><span class="token punctuation">(</span><span class="token parameter">string memory text0<span class="token punctuation">,</span> string memory text1</span><span class="token punctuation">)</span> external pure <span class="token function">returns</span><span class="token punctuation">(</span><span class="token parameter">bytes memory</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// abi.encode() 是将参数转换成十六进制编码，并补零。</span>
        <span class="token comment">// 运算的哈希值不会哈希碰撞</span>
        bytes memory encodeBy <span class="token operator">=</span> abi<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>text0<span class="token punctuation">,</span> text1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> encodeBy<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">encodePacked</span><span class="token punctuation">(</span><span class="token parameter">string memory text0<span class="token punctuation">,</span> string memory text1</span><span class="token punctuation">)</span> external pure <span class="token function">returns</span><span class="token punctuation">(</span><span class="token parameter">bytes memory</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// abi.encodePacked() 也是将参数转换为十六进制，但是这个并不补零。</span>
        <span class="token comment">// 如果用 keccak256() 运算哈希值时，会产生哈希碰撞。就是说俩次不同的值会运算同一个哈希值，这就是哈希碰撞</span>

        <span class="token comment">//    输入  aaaa bbb</span>
        <span class="token comment">//   -输出  0x61616161626262</span>
        <span class="token comment">//    输入  aaa abbb </span>
        <span class="token comment">//   -输出  0x61616161626262</span>

        <span class="token comment">// 俩次转入的值不一样，但是换算二机制的值确实一样。这样使用 keccak256() 就会出现哈希碰撞了</span>

        bytes memory encodePackedBy <span class="token operator">=</span> abi<span class="token punctuation">.</span><span class="token function">encodePacked</span><span class="token punctuation">(</span>text0<span class="token punctuation">,</span> text1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> encodePackedBy<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
     <span class="token comment">//解码   </span>
     <span class="token keyword">function</span> <span class="token function">decoded</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> view <span class="token function">returns</span><span class="token punctuation">(</span><span class="token parameter">uint256</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            bytes memory data <span class="token operator">=</span> abi<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">(</span>uint256 a<span class="token punctuation">)</span> <span class="token operator">=</span> abi<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>data <span class="token punctuation">,</span> <span class="token punctuation">(</span>uint256<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
            <span class="token keyword">return</span> a<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="合约验证签名"><a href="#合约验证签名" class="header-anchor">#</a> 合约验证签名</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/区块链/以太坊/以太坊-0001.html" class="prev">
        概念
      </a></span> <span class="next"><a href="/区块链/以太坊/web3.0.html">
        web3
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ce1393de.js" defer></script><script src="/assets/js/2.ee68cb5d.js" defer></script><script src="/assets/js/59.f41e8ae6.js" defer></script>
  </body>
</html>
